---
layout: post
title: 우당탕탕 캐시 전략
subtitle: 나는 우리 서비스를 딜레이가 없는 빠른 서비스로 만들고 싶다!!!!
categories: redis
tags: [redis, blog]
---

## 메인페이지
1. 서버 속도 : 약 2.3초
2. 앱 속도 : 2.6초

## 리스트 페이지

1. 서버 속도 : 약 1초 
2. 앱 속도  : 약 1.4초

## TV 페이지 (첫 조회)

1. 서버 속도 : 약 2.63초
2. 앱 속도  : 약 4.3초  → (다음 조회 부터 빠른 것으로 봐서는 앱쪽에서 캐시처리한 느낌)

### 결론 : 서버 처리 속도가 느리다…

# 처리방법

## Cache Data

미리데이터를 저장하는 방법이다 MySQL에서 조회될 때 당연히 해당 쿼리 명령문을 입력하여 MYSQL에서 내부 로직을 통하여 받아오는데 이 부분을 거치지 않고 미리 만들어 놓은 데이터를 이용해서 처리하는 방법

Spring에서 Cache를 쓰는 방법이 여러가지 있지만 2가지 방법을 도안했다.

1. 기본적인 Cache annotation 을 사용해서 처리를 진행하기
    
    → 해당 방법으로 사용했을 때 현재 서버는 두개의 서버가 로드밸런스로 처리되고 있는데 해당 어노테이션 방법으로 처리하면 두개의 서버 내부에 각각 캐시가 저장이 된다. 결국에 두개의 서버 데이터가 달라질 수 있다는 단점이 있기 때문에 PASS
    
2. redis를 이용하여 Cache 처리 하기
    
    → 해당 방법으로 처리 하면 두개의 서버가 로드밸런스 처리가 되어도 똑같은 캐시 데이터로 받을 수 있기 때문에 해당 방법으로 Choice
    

하지만 현재 현재 시스템에서는 실시간 데이터를 받아야 하는 상태값(접속중, 미접속중, 상담중) 이 있기떄문에 여러 전략을 생각해야 했다. ㅠㅠ

### 캐시데이터 전략

1. Server에서 주기적으로 Cache데이터를 동기화 해준다. 
    
    → 이 부분은 Server에서 시간마다 캐시메모리를 초기화를 진행하고 새로운 데이터를 넣어주는 방법이다.
    Trade-off : 아무래도 실시간을 따라잡을려면 1초마다 동기화하는 식으로 해야는데 이렇게 할 경우 
    cache miss가 일어날 가능성이 높고 서버에 부담을 줄 수 있다는 문제가 생김..
    
2. 특정 API가 동작하면 Cache데이터를 동기화 해준다.
    
    → 상담사가 상태 변경이 진행 할 때만 캐시 메모리를 넣어주는 방법 (Write-Through)
    
    Trade-off: 상담사가 상태변경을 진행할 때 캐시 메모리를 삭제 추가를 진행해야는데 기존에 상태변경은 1초도 걸리지 않았지만 캐시메모리를 동기화를 해줄 경우 2~3초 특정 API가 자주 발생하면 이것도 의미가 없지 않을까...
    
3. 상담사의 상태가 수정될 때 캐시 메모리를 삭제하고 홈, 리스트, 도사TV 부분에서 다시 조회할 때 캐시 메모리를 재요청하는 방법
    
    → 2번에서 조금더 개선된 상황인데 캐시 삽입 삭제를 나눠서 하면 조금더 부하가 덜 생기지 않을까 싶어 해당 방법으로 사용해보려고 한다.